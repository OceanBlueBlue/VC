#include <windows.h> #include <stdio.h> LRESULT CALLBACK WinSunProc( 	HWND hwnd, 	UINT uMsg, 	WPARAM wParam, 	LPARAM 1 Param )； // handle to window // message identifier // first message parameter // second message parameter int WINAPI WinMain( 	HINSTANCE hlnstance, 	HINSTANCE hPrevInstance, 	LPSTR IpCmdLine, 	int nCmdShow 	// handle to current instance 	// handle to previous instance 	// command line 	// show state  	〃设计一个窗口类 	WNDCLASS wndcls; wndcls.cbClsExtra = O; wndcls・ cbWndExtra = O; wndcls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); wndcls.hCursor = LoadCursor(NULL, IDC_CROSS)； wndcls.hIcon = LoadIcon(NULL, IDI_ERROR); wndcls.hlnstance = hlnstance;	//应用程序实例句柄由WinMain函数传进来 wndcls.IpfnWndProc = WinSunProc; wndcls.lpszClassName = "sunxin2 00 6"; wndcls.lpszMenuName = NULL; wndcls.Style = CS_HREDRAW | CS__VREDRAW; Registerclass(&wndcls); //创建窗口，定义一个变量用来保存成功创建窗口后返回的句柄 HWND hwnd; hwnd = CreateWindow("sunxin2006", nhttp://www.sunxin.org", WS.OVERLAPPEDWINDOW；0, 0, 600, 400, NULL, NULL, hlnstance, NULL); //显示及刷新窗口 ShowWindow(hwnd, SW.SHOWNORMAL); UpdateWindow(hwnd); //定义消息结构体，开始消息循环 MSG msg; while (GetMessage(&msgfNULL, 0, 0)) { 	TranslateMessage(&msg); 	DispatchMessage(&msg)； } return msg.wParam; } 〃编写窗口过程函数 LRESULT CALLBACK WinSunProc( 	HWND hwnd, 	UINT uMsg, 	WPARAM wParam, 	LPARAM 1 Param 	// handle to window 	// message identifier 	// first message parameter 	// second message parameter 	switch (uMsg) 		( case WM_CHAR: 	char szChar[20]; 	sprintf(szChar, "char code is %d", wParam); 	MessageBox(hwnd, szChar, "char11,0); 		break;  case WM_LBUTTONDOWN: 	MessageBox(hwnd, "mouse clicked", "message", 0); 	HDC hdc; 	hdc = GetDC(hwnd);	//不能在响应WM_PAINT消息时调用 	TextOut(hdc, 0, 50 / 程序员之家 - .strlenC程序员之家 - ))； 		//ReleaseDC(hwnd.hdc); 		break； case WM_PAINT: 	HDC hDC; 	PAINTSTRUCT ps； 		hDC = BeginPaint(hwnd, &ps);	//BeginPaint 只能在响应 WM_PAINT 消息 	时调用 		•TextOut(hDC, 0, 0, "http://www.sunxin.org", strlen(Hhttp：//www. 			sunxin, org")); 			EndPaint(hwnd, &ps); 	break; case WM_CLOSE: 	if (IDYES == MessageBox(hwndr "是否真的结束？ ", "message", MB.YESNO)) 	{ 		DestroyWindow(hwnd); 	} 	break； case WM_DESTROY: 	PostQuitMessage(0); 	break； default: 	return DefWindowProc(hwnd, uMsg, wParam, 1Param)； } return 0; }